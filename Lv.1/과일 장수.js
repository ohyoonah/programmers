// 과일 장수가 사과 상자를 포장하고 있습니다.
// 사과는 상태에 따라 1점부터 k점까지의 점수로 분류하며,
// k점이 최상품의 사과이고 1점이 최하품의 사과입니다.
// 사과 한 상자의 가격은 다음과 같이 결정됩니다.
// 한 상자에 사과를 m개씩 담아 포장합니다.
// 상자에 담긴 사과 중 가장 낮은 점수가 p (1 ≤ p ≤ k)점인 경우, 사과 한 상자의 가격은 p * m 입니다.
// 과일 장수가 가능한 많은 사과를 팔았을 때, 얻을 수 있는 최대 이익을 계산하고자 합니다.(사과는 상자 단위로만 판매하며, 남는 사과는 버립니다)

function solution(k, m, score) {
  // score 배열을 내림차순 정렬해 줌 => 최댓값을 구해야 하기 때문 => 남는 사과는 버려야 하니 점수가 작은 사과를 버림
  score.sort((a, b) => b - a);
  let result = 0;
  // 시작 인덱스는 m - 1 => 0번째 인덱스부터 m - 1번째 인덱스까지 한 상자에 담음
  // 다음 상자는 i += m번째 인덱스부터 시작
  // 이렇게 하는 이유는 각각의 상자에 담긴 최솟값을 곱해야 하기 때문
  for (let i = m - 1; i < score.length; i += m) {
    // i번째 인덱스의 값과 한 상자에 들어가는 사과의 수 m을 곱해서 result에 더해줌
    result += score[i] * m;
  }
  return result;
}

// k = 4,	m = 3, score = [4, 1, 2, 2, 4, 4, 4, 4, 1, 2, 4, 2]
// 내림차순 정렬 => [4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 1, 1]
// m - 1 인덱스 => score[2] => 4 / score.length => 12 / i += m => 2 + 3 ...
// result => (score[2] + score[5] + score[8] + score[11]) * m => (4 + 4 + 2 + 1) * 3
